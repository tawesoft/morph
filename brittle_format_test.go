package morph_test

import (
    "testing"

    "github.com/tawesoft/morph"
    "github.com/tawesoft/morph/internal"
)

// This file implements tests of exact outputs expected to be generated by
// Morph.
//
// The exact output generated by Morph may change, without meaningfully
// changing any semantics of the generated code. This means that these tests
// are extremely brittle, and it's okay if they fail initially.
//
// To fix a failing test, it's necessary to examine the generated output,
// manually eyeball that it looks correct, and update the test to expect the
// newly generated output.
//
// The actual *behaviour* of a generated output, rather than its mere
// appearance with comments, whitespace, etc., is not tested here but rather
// by executing the generated code and verifying it compiles and runs and
// prints an expected result (this is done in generated_test.go).

func TestStruct_CustomFunction(t *testing.T) {
    fetIsZero := &morph.FieldExpressionType{
        Name:    "IsZero",
        Targets: 1,
        Type:    morph.FieldExpressionTypeBool,
        Default: "$(this) == (func() (_zero $(this).$(type)) { return })()",
        Comment: "$ returns true if every field on $self is zero.",
        FieldComment: "is $(this) (type $(this).$(type)) zero?",
        Collect: "&&",
    }
    fetEqual := &morph.FieldExpressionType{
        Name:    "Equal",
        Targets: 2,
        Type:    morph.FieldExpressionTypeBool,
        Default: "$a.$ == $b.$",
        Comment: "$ returns true if $a equals $b.",
        FieldComment: "are values $a.$ (type $a.$.$type) and $b.$ (type $b.$.$type) equal?",
        Collect: "&&",
    }
    fetZero := &morph.FieldExpressionType{
        Name:    "Zero",
        Targets: 1,
        Type:    morph.FieldExpressionTypeValue,
        Default: "$this = (func() (_zero $(this).$(type)) { return })()",
        Comment: "$ sets $self to its zero value.",
        FieldComment: "set $this (type $this.$type) to zero",
    }
    fetSet := &morph.FieldExpressionType{
        Name:    "Set",
        Targets: 2,
        Type:    morph.FieldExpressionTypeValue,
        Default: "$dest.$ = $src.$",
        Comment: "$ sets $dest to the value of $src.",
        FieldComment: "copy $src.$ (type $src.$.$type) to $dest.$ (type $dest.$.$type)",
    }

    apple := morph.Struct{
        Name: "Apple",
        Fields: []morph.Field{
            {
                Name:      "Picked",
                Type:      "time.Time",
                Custom:    []morph.FieldExpression{
                    {
                        Type:    fetIsZero,
                        Pattern: "$(this).IsZero()",
                    },
                    {
                        Type:    fetEqual,
                        Pattern: "$a.$.Equals($b.$)",
                    },
                    {
                        Type:    fetSet,
                        Pattern: "$dest.$ = $src.$.UTC()",
                    },
                    {
                        Type:    fetZero,
                        Pattern: "$this = time.Zero()",
                    },
                },
            },
            {
                Name:      "Weight",
                Type:      "int64",
                Comment:   "grams",
            },
        },
    }

    tests := []struct{
        do func() (morph.Function, error)
        expected string
    }{
        {
            func() (morph.Function, error) {
                return apple.CustomUnaryFunction(fetIsZero.Name, "($self.$type.$untitle *$self.$type) $()() bool")
            },
            internal.Must(internal.FormatSource(`
// IsZero returns true if every field on apple is zero.
func (apple *Apple) IsZero() bool {
    // is apple.Picked (type time.Time) zero?
    _cmp0 := bool(apple.Picked.IsZero())
    if !_cmp0 {
        return false
    }

    // is apple.Weight (type int64) zero?
    _cmp1 := bool(apple.Weight == (func() (_zero int64) { return })())
    if !_cmp1 {
        return false
    }

    return true
}
`)),
        },

        {
            func() (morph.Function, error) {
                return apple.CustomBinaryFunction(fetEqual.Name, "Equal(x $a.$type, y $a.$type) bool", apple)
            },
            internal.Must(internal.FormatSource(`
// Equal returns true if x equals y.
func Equal(x Apple, y Apple) bool {
    // are values x.Picked (type time.Time) and y.Picked (type time.Time) equal?
    _cmp0 := bool(x.Picked.Equals(y.Picked))
    if !_cmp0 {
        return false
    }

    // are values x.Weight (type int64) and y.Weight (type int64) equal?
    _cmp1 := bool(x.Weight == y.Weight)
    if !_cmp1 {
        return false
    }

    return true
}
`)),
        },

        {
            func() (morph.Function, error) {
                return apple.CustomBinaryFunction(fetSet.Name, "($src.$type.$untitle $src.$type) Copy() $dest.$type", apple)
            },
            internal.Must(internal.FormatSource(`
// Set sets _unnamed_dest to the value of apple.
func (apple Apple) Copy() Apple {
    _out := Apple{}

    // copy apple.Picked (type time.Time) to _unnamed_dest.Picked (type time.Time)
    _out.Picked = apple.Picked.UTC()

    // copy apple.Weight (type int64) to _unnamed_dest.Weight (type int64)
    _out.Weight = apple.Weight

    return _out
}
`)),
        },
        {
            func() (morph.Function, error) {
                return apple.CustomUnaryFunction(fetZero.Name, "$()() Apple")
            },
            internal.Must(internal.FormatSource(`
// Zero sets _unnamed_self to its zero value.
func Zero() Apple {
    _out := Apple{}

    // set _unnamed_self.Picked (type time.Time) to zero
    _out.Picked = time.Zero()

    // set _unnamed_self.Weight (type int64) to zero
    _out.Weight = (func() (_zero int64) { return })()

    return _out
}
`)),
        },
        {
            func() (morph.Function, error) {
                return apple.CustomBinaryFunction(fetSet.Name, "Copy(dest *Apple, src Apple)", apple)
            },
            internal.Must(internal.FormatSource(`
// Set sets dest to the value of src.
func Copy(dest *Apple, src Apple) {
    _out := Apple{}

    // copy src.Picked (type time.Time) to dest.Picked (type time.Time)
    _out.Picked = src.Picked.UTC()

    // copy src.Weight (type int64) to dest.Weight (type int64)
    _out.Weight = src.Weight

    *dest = _out
}
`)),
        },
    }

    for i, tt := range tests {
        f, err := tt.do()
        if err != nil {
            t.Errorf("test %d: unexpected error: %v", i, err)
            continue
        }
        if f.String() != tt.expected {
            t.Logf("expected: %s", tt.expected)
            t.Logf("got: %s", f.String())
            t.Errorf("test %d: unexpected output", i)
        }
    }
}

func TestWrappedFunction_String(t *testing.T) {
    divide := morph.Function{
        Signature: morph.FunctionSignature{
            Name:      "Divide",
            Comment:   "Divide returns a divided by b. It is an error to divide by zero.",
            Arguments: []morph.Argument{
                {Name: "a", Type: "float64"},
                {Name: "b", Type: "float64"},
            },
            Returns:   []morph.Argument{
                {Name: "value", Type: "float64"},
                {Name: "err",   Type: "error"},
            },
        },
        Body: `
    if b == 0.0 {
        return 0, DivideByZeroError
    } else {
        return a / b, nil
    }
`,
    }.Wrap()
    simpleOneInput := morph.Function{
        Signature: morph.FunctionSignature{
            Name: "SimpleOneInput",
            Arguments: []morph.Argument{
                {Name: "x", Type: "float64"},
            },
        },
        Body: "x = x",
    }.Wrap()
    foo := morph.Function{
        Signature: morph.FunctionSignature{
            Name:      "Foo",
            Arguments: []morph.Argument{
                {Name: "foo", Type: "float64"},
            },
            Returns:   []morph.Argument{
                {Type: "float64"},
            },
        },
        Body: `
        return 2 * foo
`,
    }.Wrap()
    divide2 := morph.WrappedFunction{
        Signature: morph.FunctionSignature{
            Comment:   "$ returns the result of [Divide] with the result rewritten as (value, err == nil).",
            Name:      "Divide_ReturnValueOk",
            Arguments: []morph.Argument{
                {Name: "a", Type: "float64"},
                {Name: "b", Type: "float64"},
            },
            Returns:   []morph.Argument{
                {Type: "float64"},
                {Type: "bool"},
            },
        },
        Inputs: morph.ArgRewriter{
            Capture: []morph.Variable{
                {Name: "i", Type: "float64", Value: "$a",},
                {Name: "j", Type: "float64", Value: "$b",},
            },
            Formatter: "$i, $j",
        },
        Outputs: morph.ArgRewriter{
            Capture: []morph.Variable{
                {Name: "f",  Type: "float64", Value: "$value"},
                {Name: "ok", Type: "bool",    Value: "$err == nil"},
            },
            Formatter: "$f, $ok",
        },
        Wraps: &divide,
    }

    tests := []struct{
        wrapped morph.WrappedFunction
        expected string
        fails bool
    }{
        {
            wrapped: morph.WrappedFunction{
                Signature: morph.FunctionSignature{
                    Name:      "SimpleConstArg",
                },
                Inputs: morph.ArgRewriter{
                    Formatter: "2",
                },
                Wraps: &simpleOneInput,
            },
            expected: `
func SimpleConstArg() {
    SimpleOneInput(2)

    return
}
`,
        },
        {
            wrapped: morph.WrappedFunction{
                Signature: morph.FunctionSignature{
                    Name:      "FailsInputNotReferenced",
                    Arguments: []morph.Argument{
                        {Name: "a", Type: "float64"},
                    },
                },
                Inputs: morph.ArgRewriter{
                    Formatter: "2",
                },
                Wraps: &simpleOneInput,
            },
            fails: true,
        },
        {
            wrapped: morph.WrappedFunction{
                Signature: morph.FunctionSignature{
                    Name:      "FailsByIndex",
                    Arguments: []morph.Argument{
                        {Name: "a", Type: "float64"},
                    },
                },
                Inputs: morph.ArgRewriter{
                    Capture:   []morph.Variable{
                        {Name: "", Type: "float64", Value: "$1",},
                    },
                    Formatter: "$0",
                },
                Wraps: &simpleOneInput,
            },
            fails: true,
        },
        {
            wrapped: divide2,
            expected: `
// Divide_ReturnValueOk returns the result of [Divide] with the result rewritten as (value, err == nil).
func Divide_ReturnValueOk(a float64, b float64) (float64, bool) {
    _in0 := a // accessible as $0 or $i
    _in1 := b // accessible as $1 or $j

    _r0, _r1 := Divide(_in0, _in1) // results accessible as $value, $err

    _out0 := _r0        // accessible as $0 or $f
    _out1 := _r1 == nil // accessible as $1 or $ok

    return _out0, _out1
}
`,
        },
        {
            wrapped: morph.WrappedFunction{
                Signature: morph.FunctionSignature{
                    Comment:   "$ returns the result of Divide(a, 2) as (float64, bool) by wrapping Divide_ReturnValueOk.",
                    Name:      "Divide_Const_ReturnValueOk",
                    Arguments: []morph.Argument{
                        {Name: "a", Type: "float64"},
                    },
                    Returns:   []morph.Argument{
                        {Type: "float64"},
                        {Type: "bool"},
                    },
                },
                Inputs: morph.ArgRewriter{
                    Capture: []morph.Variable{
                        {Type: "float64", Value: "$0"},
                    },
                    Formatter: "$0, 2",
                },
                Outputs: morph.ArgRewriter{
                    Capture: []morph.Variable{
                        {Type: "float64", Value: "$0"},
                        {Type: "bool",    Value: "$1"},
                    },
                    Formatter: "$0, $1",
                },
                Wraps: &divide2,
            },
            expected: `
// Divide_Const_ReturnValueOk returns the result of Divide(a, 2) as (float64, bool) by wrapping Divide_ReturnValueOk.
func Divide_Const_ReturnValueOk(a float64) (float64, bool) {
    // from Divide_ReturnValueOk
    _f0 := func(a float64, b float64) (float64, bool) {
    _in0 := a // accessible as $0 or $i
    _in1 := b // accessible as $1 or $j

        _r0, _r1 := Divide(_in0, _in1) // results accessible as $value, $err

        _out0 := _r0        // accessible as $0 or $f
        _out1 := _r1 == nil // accessible as $1 or $ok

        return _out0, _out1
    }

    _in0 := a // accessible as $0

    _r0, _r1 := _f0(_in0, 2) // results accessible as $0, $1

    _out0 := _r0 // accessible as $0
    _out1 := _r1 // accessible as $1

    return _out0, _out1
}
`,
        },
        {
            wrapped: morph.WrappedFunction{
                Signature: morph.FunctionSignature{
                    Comment:   "$ returns the result of math.Modf(Foo(x)).",
                    Name:      "Foo_Modf",
                    Arguments: []morph.Argument{
                        {Name: "x", Type: "float64"},
                    },
                    Returns:   []morph.Argument{
                        {Type: "float64"},
                        {Type: "float64"},
                    },
                },
                Inputs: morph.ArgRewriter{
                    Capture: []morph.Variable{
                        {Type: "float64", Value: "$0"},
                    },
                    Formatter: "$0",
                },
                Outputs: morph.ArgRewriter{
                    Capture: []morph.Variable{
                        {Type: "float64, float64", Value: "math.Modf($0)"},
                    },
                    Formatter: "$0.0, $0.1",
                },
                Wraps: &foo,
            },
            expected: `
// Foo_Modf returns the result of math.Modf(Foo(x)).
func Foo_Modf(x float64) (float64, float64) {
    _in0 := x // accessible as $0

    _r0 := Foo(_in0) // results accessible as $0

    _out0_0, _out0_1 := math.Modf(_r0) // accessible as $0.N

    return _out0_0, _out0_1
}
`,
        },
    }

    for _, tt := range tests {
        t.Run(tt.wrapped.Signature.Name, func(t *testing.T) {
            result, err := tt.wrapped.Format()
            if tt.fails != (err != nil) {
                if tt.fails == false {
                    t.Errorf("error formatting wrapped function: %v", err)
                } else {
                    t.Errorf("wrapped function successfully, but expected to fail")
                }
                return
            }

            expected := internal.Must(internal.FormatSource(tt.expected))
            if result != expected {
                t.Logf("got:\n%+v", result)
                t.Logf("expected:\n%+v", expected)
                t.Errorf("wrapped function does not format as expected")
            }
        })
    }
}


/*
func TestFunctionSignature_Bind(t *testing.T) {
    // TODO remove this

    divide := morph.Function{
        Signature: morph.FunctionSignature{
            Name:      "Divide",
            Comment:   "Divide returns a divided by b. It is an error to divide by zero.",
            Arguments: []morph.Argument{
                {Name: "a", Type: "float64"},
                {Name: "b", Type: "float64"},
            },
            Returns:   []morph.Argument{
                {Name: "value", Type: "float64"},
                {Name: "err",   Type: "error"},
            },
        },
        Body: `
    if b == 0.0 {
        return 0, DivideByZeroError
    } else {
        return a / b, nil
    }
`,
    }

    tests := []struct{
        Name string
        Input interface{Bind(string, []morph.Field) (morph.Function, error)}
        Args []morph.Field
        Expected string
        Fails bool
    }{
        {
            Name: "Divide0",
            Input: divide.Signature,
            Args: []morph.Field{
            },
            Expected: `
func Divide0() func(a float64, b float64) (value float64, err error) {
    return func(a float64, b float64) (value float64, err error) {
        return Divide(a, b)
    }
}
`,
        },
        {
            Name: "Divider",
            Input: divide.Signature,
            Args: []morph.Field{
                {Name: "b"},
            },
            Expected: `
// Divider returns a function that implements [Divide]
// with the argument b already applied.
func Divider(b float64) func(a float64) (value float64, err error) {
    return func(a float64) (value float64, err error) {
        return Divide(a, b)
    }
}
`,
        },
        {
            Name: "DividerFull",
            Input: divide,
            Args: []morph.Field{
                {Name: "b"},
            },
            Expected: `
// DividerFull returns a function that implements [Divide]
// with the argument b already applied.
func DividerFull(b float64) func(a float64) (value float64, err error) {
    return func(a float64) (value float64, err error) {
        return func(a float64, b float64) (value float64, err error) {
            if b == 0.0 {
                return 0, DivideByZeroError
            } else {
                return a / b, nil
            }
        }(a, b)
    }
}
`,
        },
    }

    for _, tt := range tests {
        t.Run(tt.Name, func(t *testing.T) {
            result, err := tt.Input.Bind(tt.Name, tt.Args)
            if tt.Fails != (err != nil) {
                if tt.Fails == false {
                    t.Errorf("error binding function: %v", err)
                } else {
                    t.Errorf("bound function successfully, but expected to fail")
                }
                return
            }

            expected := internal.Must(internal.FormatSource(tt.Expected))
            if result.String() != expected {
                t.Logf("got:\n%+v", result.String())
                t.Logf("expected:\n%+v", expected)
                t.Errorf("bound function does not format as expected")
            }
        })
    }
}
*/
